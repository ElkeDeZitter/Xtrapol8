options{
    programs = *run_JackKnife *run_Xtrapol8
            .type = choice(multi=True)
            .help = Program to run
            .expert_level = 0
    processors = 100
        .type = int
        .help = Number of processors to be used for the program
        .expert_level = 1
    }
JackKnife{
    input{
        repeats = 4
            .type = int
            .help = Number of times JackKnife will be repeated
            .expert_level = 0
        fraction = 0.9
            .type = float(value_min=0, value_max=1)
            .help = Percentage of images used for JackKnife (fractional)
            .expert_level = 0
        directory_crystfel_programs = /usr/local/bin
            .type = path
            .help = path where the CrystFEL programs like process_hkl are found (example: /usr/local/bin)
            .expert_level = 0
        }
    Off_state{
        stream_file_off = /mnt/ibs-equipe-weik.04/edezitter/JK_testdata/WT_all_rings_nocen_19675crystals.stream
            .type = path
            .help = File with images to process for the off state or only state in stream format
            .expert_level = 0
        unit_cell{
            use_UC_and_SG_from_pdb = True
                .type = bool
                .help = use the unit cell and space group from pdb file given
                .expert_level = 0
            a = None
                .type = float
                .help = lattice a axis length (A)
                .expert_level = 0
            b =None
                .type = float
                .help = lattice b axis length (A)
                .expert_level = 0
            c =None
                .type = float
                .help = lattice c axis length (A)
                .expert_level = 0
            alpha =None
                .type = float
                .help = lattice alpha angle (degree)
                .expert_level = 0
            beta =None
                .type = float
                .help = lattice beta angle (degree)
                .expert_level = 0
            gamma =None
                .type = float
                .help = lattice gamma angle (degree)
                .expert_level = 0
            }
            spacegroup =None
                .type = str
                .help = space group of the processed crystal
                .expert_level = 0
            unique_axis = default a *b c
                .type = choice(multi=False)
                .help = symmetry axis
                .expert_level = 0
        }
    On_state{
        stream_file_on = /mnt/ibs-equipe-weik.04/edezitter/JK_testdata/D76N_ALL_rings_nocen.stream
            .type = path
            .help = File with images to process for the on state in stream format
            .expert_level = 0
        unit_cell{
            a = None
                .type = float
                .help = lattice a axis length (A)
                .expert_level = 0
            b = None
                .type = float
                .help = lattice b axis length (A)
                .expert_level = 0
            c = None
                .type = float
                .help = lattice c axis length (A)
                .expert_level = 0
            alpha = None
                .type = float
                .help = lattice alpha angle (degree)
                .expert_level = 0
            beta = None
                .type = float
                .help = lattice beta angle (degree)
                .expert_level = 0
            gamma = None
                .type = float
                .help = lattice gamma angle (degree)
                .expert_level = 0
            }
            spacegroup = C121
                .type = str
                .help = space group of the processed crystal
                .expert_level = 0
            unique_axis = default a *b c
                .type = choice(multi=False)
                .help = symmetry axis
                .expert_level = 0
        }
    Scaling_and_merging{
        algorithm = *process_hkl partialator
            .type = choice(multi=False)
            .help = Method for intensity merging
            .expert_level = 0
        process_hkl{
            other_process_hkl = --max-adu=30000 --scale --no-polarisation
                .type = str
                .help = other inputs for the process_hlk merging of images. For more infromation go to https://www.desy.de/~twhite/crystfel/manual.html (written like inputs for Crystfel, example: --min-snr=1)
                .expert_level = 0
            }
        partialator{
            other_partialator = --iterations=1 --model=unity
                .type = str
                .help = other inputs for the process_hlk merging of images.
                .expert_level = 0
            }
        }
    Statistics{
        other_stats_compare_hkl = None
            .type = str
            .help = other inputs for the compare_hkl getting statistics.
            .expert_level = 0
        }
    }
Xtrapol8{
    input{
        reference_mtz = /mnt/ibs-equipe-weik.04/edezitter/PaulaOeser/Xtrapol8_test_0/D76N_ALL_rings_nocen_JackKnife_Xtrapol8_20/JK_WT_all_rings_nocen_19675crystals_reference/WT_all_rings_nocen_19675crystals_total/WT_all_rings_nocen_19675crystals.mtz
            .type = path
            .help = Reference data in mtz or mmcif format (merged).
            .expert_level = 0
        triggered_mtz = /mnt/ibs-equipe-weik.04/edezitter/PaulaOeser/Xtrapol8_test_0/D76N_ALL_rings_nocen_JackKnife_Xtrapol8_20/JK_D76N_ALL_rings_nocen_triggered/D76N_ALL_rings_nocen_total/D76N_ALL_rings_nocen.mtz
            .type = path
            .help = Triggered data in mtz or mmcif format (merged).
            .expert_level = 0
        reference_pdb = /mnt/ibs-equipe-weik.04/edezitter/JK_testdata/WT_XFEL_refine_13.pdb
            .type = path
            .help = Reference coordinates in pdb or mmcif format. (in former versions this was called model_pdb)
            .expert_level = 0
        additional_files = None
            .type = path
            .multiple = True
            .help = Additional files required for refinement, e.g ligand cif file, restraints file.
            .expert_level = 0
        high_resolution = None
            .type = float
            .help = High resolution cutoff (Angstrom). Will only be used if high resolution of the input data files extends to this value.
            .expert_level = 0
        low_resolution = None
            .type = float
            .help = Low resolution cutoff (Angstrom).
            .expert_level = 0
        }
    occupancies{
        low_occ = 0.1
            .type = float(value_min=0, value_max=1)
            .help = Lowest occupancy to test (fractional)
            .expert_level = 0
        high_occ = 0.9
            .type = float(value_min=0, value_max=1)
            .help = Highest occupancy to test (fractional)
            .expert_level = 0
        steps = 2
            .type = int
            .help = Amount of equaly spaced occupancies to be tested
            .expert_level = 0
        list_occ = None
            .type = floats(size_min=1, value_min=0, value_max=1)
            .help = List of occupancies to test (fractional). Will overwrite low_occ, high_occ and steps if defined
            .expert_level = 0
        }
    scaling{
        b_scaling = no isotropic *anisotropic
            .type = choice(multi=False)
            .help = B-factor scaling for scaling triggered data vs reference data. Cannot be used for reference data with fcalc when using mmtbx.fmodel.manager.
            .expert_level = 0
        }
    f_and_maps{
        fofo_type = *qfofo fofo kfofo
            .type = choice(multi=False)
            .help = Calculate q-weighted or non-q-weighted Fo-Fo difference map. Q-weighted is highly recommended. K-weighting is under development
            .expert_level = 1
        kweight_scale = 0.05
            .type = float(value_min=0, value_max=1)
            .help = scale factor for structure factor difference in k-weigting scheme (for calculation of kfofo)
            .expert_level = 3
        f_extrapolated_and_maps = *qfextr *fextr kfextr qfgenick fgenick kfgenick qfextr_calc fextr_calc kfextr_calc
            .type = choice(multi=True)
            .help = Extrapolated structure factors and map types: qFextr, kFextr, Fextr: (q/k-weighted)-Fextr structure factors and maps by Coquelle method (Fextr= alpha*(Fobs,triggered-Fobs,reference)+Fobs,triggered, map 2mFextr|-D|Fcalc|, phi_model). qFgenick, kFgenick, Fgenick: (q/k-weighted)-Fextr structure factors and maps by Genick method (|Fextr|= alpha*(|Fobs,triggered|-|Fobs,reference|)+|Fobs,triggered|, map: m|Fextr|, phi_model). qFextr_calc, kFextr_calc, Fextr_calc: (q-weighted)-Fextr structure factors and maps by Fcalc method (|Fextr|= alpha*(|Fobs,triggered|-|Fobs,reference|)+|Fcalc|, map" 2m|Fextr|-D|Fcalc|, phi_model).
            .expert_level = 0
        all_maps = False
            .type = bool
            .help = Calculate all extrapolated structure factors and maps
            .expert_level = 0
        only_qweight = False
            .type = bool
            .help = Calculate all extrapolated structure factors and maps with q-weighting
            .expert_level = 0
        only_kweight = False
            .type = bool
            .help = Calculate all extrapolated structure factors and maps with q-weighting
            .expert_level = 0
        only_no_weight = False
            .type = bool
            .help = Calculate all extrapolated structure factors and maps without q/k-weighting
            .expert_level = 0
        fast_and_furious = True
            .type = bool
            .help = Run fast and furious (aka without supervision). Will only calculate qFextr and associated maps, use highest peaks for alpha/occupancy determination (alpha/occupancy will be nonsense if map_explorer parameters being bad), run refinement with finally with derived alpha/occupancy, use truncate_and_fill for negative and missing handling. Usefull for a first quick evaluation.
            .expert_level = 0
        negative_and_missing = *truncate_and_fill truncate_no_fill fref_and_fill fref_no_fill fcalc_and_fill fcalc_no_fill fill_missing no_fill reject_and_fill reject_no_fill zero_and_fill zero_no_fill
            .type = choice(multi=False)
            .help = Handling of negative and missing extrapolated reflections (note that this will not be applied on FoFo difference maps). Please check the manual for more information. This parameters is NOT applicable for (q)Fgenick because negative reflections are rejected anyway. For refinement, default phenix.refine or refmac handling of negative/missing reflections is applied.
            .expert_level = 2
        }
    map_explorer{
        threshold = 3.5
            .type = float
            .help = Integration threshold (in sigma)
            .expert_level = 0
        peak = 4.0
            .type = float
            .help = Peak detection threshold (sigma)
        radius = None
            .type = float
            .help = Maximum radius (A) to allocate a density blob to a protein atom in map explorer. Resolution will be used if not specified.
            .expert_level = 0
        z_score = 2.0
            .type = float
            .help = Z-score to determine residue list with only highest peaks
            .expert_level = 0
        use_occupancy_from_distance_analysis = False
            .type = bool
            .help = Use occupancy from determination based on the differences between reference_pdb and real-space refined model (only in calm_and_curious mode) instead of map explorer
            .expert_level = 1
        }
    refinement{
        run_refinement = True
        .type = bool
        .help = Run the automatic refinements. Setting this parameter to False can be useful when a manual intervention is required before running the refinements. The Refiner.py script can be used to run the refinements and subsequent analysis afterwards.
        .expert_level = 1
        use_refmac_instead_of_phenix = False
            .type = bool
            .help = use Refmac for reciprocal space refinement and COOT for real-space refinement instead of phenix.refine and phenix.real_space_refine
            .expert_level = 0
        phenix_keywords{
            target_weights{
                wxc_scale = 0.5
                .type = float
                .help = see phenix.refine refinement.target_weights.wxc_scale
                .expert_level = 2
                wxu_scale = 1.0
                .type = float
                .help = phenix.refine refinement.target_weights.wxu_scale
                .expert_level = 2
                weight_selection_criteria{
                    bonds_rmsd = None
                    .type = float
                    .help = phenix.refine refinement.target_weights.weight_selection_criteria.bonds_rmsd
                    .expert_level = 3
                    angles_rmsd = None
                    .type = float
                    .help = phenix.refine refinement.target_weights.weight_selection_criteria.angles_rmsd
                    .expert_level = 3
                    r_free_minus_r_work = None
                    .type = float
                    .help = phenix.refine refinement.target_weights.weight_selection_criteria.r_free_minus_r_work
                    .expert_level = 3
                    }
                }
            refine{
                strategy = *individual_sites individual_sites_real_space rigid_body *individual_adp group_adp tls occupancies group_anomalous
                .type = choice(multi=True)
                .help = see phenix.refine refinement.refine.strategy
                .expert_level = 1
                }
            main{
                cycles = 1
                .type = int
                .help = Number of refinement macro cycles for reciprocal space refinement
                .expert_level = 0
                ordered_solvent = False
                .type = bool
                .help = Add and remove ordered solvent during reciprocal space refinement
                .expert_level = 0
                simulated_annealing = False
                .type = bool
                .help = Simulated annealing during refinement
                .expert_level = 1
                }
            simulated_annealing{
                start_temperature = 5000
                .type = float
                .help = start temperature for simulated annealing
                .expert_level = 2
                final_temperature = 300
                .type = float
                .help = final temperature for simulated annealing
                .expert_level = 2
                cool_rate = 100
                .type = float
                .help = cool rate for simulated annealing
                .expert_level = 2
                mode = every_macro_cycle *second_and_before_last once first first_half
                .type = choice(multi=False)
                .help = simulated annealing mode
                .expert_level = 2
                }
            map_sharpening{
                map_sharpening = False
                .type = bool
                .help = phenix map sharpening
                .expert_level = 1
                }
            real_space_refine{
                cycles = 1
                .type = int
                .help = Number of refinement cycles for real space refinement
                .expert_level = 0
                }
            density_modification{
                density_modification = False
                .type = bool
                .help = use dm (ccp4) for density modification
                .expert_level = 2
                combine = *PERT OMIT
                .type = choice(multi=False)
                .help = dm combine mode
                .expert_level = 2
                cycles = 10
                .type = int
                .help = number of dm cycles (ncycle keyword). Use only few cycles in case of combine=OMIT
                .expert_level = 2
                }
            }
        refmac_keywords{
            target_weights{
                weight = *AUTO MATRIx
                .type = choice(multi=False)
                .help = refmac WEIGHT
                .expert_level = 1
                weighting_term = 0.2
                .type = float
                .help = refmac weighting term in case of weight matrix
                .expert_level = 2
                experimental_sigmas = *NOEX EXPE
                .type = choice(multi=False)
                .help = refmac use experimental sigmas to weight Xray terms
                .expert_level = 2
                }
            restraints{
                jelly_body_refinement = False
                .type = bool
                .help = run refmac ridge regression, also known as jelly body jelly body refinement. Slow refinement convergence, so take at least 50 refinement cycles.
                .expert_level = 1
                jelly_body_sigma = 0.03
                .type = float
                .help = sigma parameter in case of jelly body refinement ('RIDG DIST SIGM' parameter)
                .expert_level = 2
                jelly_body_additional_restraints = None
                .type = str
                .multiple = True
                .help = additional jelly body parameters (will be added to keyword 'RIDG')
                .expert_level = 2
                external_restraints = None
                .type = str
                .multiple = True
                .help = refmac external restraints (will be added to keyword 'external', e.g. 'harmonic residues from 225 A to 250 A atom CA sigma 0.02')
                .expert_level = 2
                }
            refine{
                type = *RESTrained UNREstrained RIGId
                .type = choice(multi=False)
                .help = refmac refinement type refinement
                .expert_level = 1
                TLS = False
                .type = bool
                .help = tls refinement before coordinate and B-factor refinement
                .expert_level = 1
                TLS_cycles = 20
                .type = int
                .help = number of TLS cycles in case of TLS refinement
                .expert_level = 2
                bfac_set = 30
                .type = float
                .help = reset individual B-factors to constant value before running TLS. Will only be applied in case TLS is run
                .expert_level = 2
                twinning = False
                .type = bool
                .help = do refmac twin refinement
                .expert_level = 1
                Brefinement = OVERall *ISOTropic
                .type = choice(multi=False)
                .help = refmac B-factor refinement
                .expert_level = 1
                cycles = 20
                .type = int
                .help = Number of refinement cycles for reciprocal space refinement
                .expert_level = 0
                }
            map_sharpening{
                map_sharpening = False
                .type = bool
                .help = refmac map sharpening
                .expert_level = 1
                }
            density_modification{
                density_modification = False
                .type = bool
                .help = use dm for density modification
                .expert_level = 2
                combine = *PERT OMIT
                .type = choice(multi=False)
                .help = dm combine mode
                .expert_level = 2
                cycles = 10
                .type = int
                .help = number of dm cycles (ncycle keyword). Use only few cycles in case of combine=OMIT
                .expert_level = 2
                }
            }
        }
    output{
        generate_phil_only = False
            .type = bool
            .help = Generate input phil-file and quit.
            .expert_level = 0
        generate_fofo_only = False
            .type = bool
            .help = Stop Xtrapol8 after generation of Fourier Difference map
            .expert_level = 0
        open_coot = False
            .type = bool
            .help = Automatically open COOT at the end.
            .expert_level = 0
        ddm_scale = 1.5
            .type = float
            .help = The ddm colors will range from -scale to +scale.
            .expert_level = 2
        }
    }
output{
    outdir = /mnt/ibs-equipe-weik.04/edezitter/PaulaOeser/Xtrapol8_test_0
        .type = str
        .help = Output directory. Current directory directory will be used if not specified.
        .expert_level = 0
    outname = None
        .type = str
        .help = Output prefix. Prefix of triggered_mtz will be used if not specified.
        .expert_level = 0
    GUI = False
        .type = bool
        .help = Xtrapol8 launched from GUI.
        .expert_level = 3
    }